# Operating system concurrency from entry to giving up

## 多任务系统并发
* C语言`printf`函数底层使用的是操作系统`write(fd,buf,1,TiB)`
* `write`的实现是操作系统的一部分
* *  `X86-64`应用程序执行`syscall`后会进入操作系统执行，此时应用程序不可见
* * 此时程序运行在处理器的高特权级;能够访问硬件设备
* * 此时不能一致霸占处理器执行，需要允许其它进程执行，否则给人感觉系统卡死了
* * 若其它进程也访问同样的数据，此时就需要并发!


|处理器数量|是否共享内存|典型的并发系统|并发/并行|
|:-:|:-:|:-:|:-:|
|单处理器|共享内存|OS内核/多线程程序|并发不并行|
|多处理器|共享内存|OS内核/多线程程序/GPU Kernel|并发，并行|
|多处理器|不共享内存|分布式系统(消息通信)|并发，并行|

```C
extern int x;
int foo(){
  int volatile t = x;
  t += 1;
  x = t;
}
```
* `foo`的代码是共享的，全局变量也是共享的
* 但是寄存器是每个线程独享的，因此线程的堆栈也是独享的

`POSIX Threads`为我们提供了线程库
* 使用`pthread_create`创建并运行某个线程
* 使用`pthread_join`等待某个线程结束
